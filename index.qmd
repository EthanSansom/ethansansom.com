---
page-layout: custom
---

```{r notes}
#| echo = FALSE

# IMPORTANT:
# See here: https://stackoverflow.com/questions/15649244/responsive-font-size-in-css
# For a responsive font-size suggestion from ashuvssut (not at the top).
#
# // Clamp font size
# h1{
#  font-size : clamp(2rem, 10vw, 5rem);
# }
#
# // Clamp font awesome icon size (we should use these)
# .fa-random-icon {
#   font-size: clamp( 15rem, 80vw, 80vh)   
# }
#
# TODO: Make a clearer system for the sizing (and relative sizing)
# of all the fonts in the ecosystem:
# - body
# - page title
# - navbar title + navbar logo text
# - headers

# - Including images from a folder:
#   https://github.com/r-lgbtq/rainbowr.org/tree/main/posts/2024-06-07_new-look
```

Hi. I’m Ethan, a Masters of Statistics student at the University of Toronto. I also work as a freelance data-analyst for the <a href="https://www.openresearchlab.org/about" class="black-link">Open Research Lab</a>, a San Fransisco based research group, and for Toronto’s own <a href="https://www.cleanairpartnership.org/about/" class="black-link">Clean Air Partnership</a>, a charitable environmental organization.

My research interests include reproducibility in social science research, causal inference, and statistical software design. Click the black boxes ↓ to preview some of my personal projects.


```{r load-posts}
#| include = FALSE

library(yaml)
library(here)

posts_directory <- here::here("posts")
posts_folders_relative_paths <- file.path("posts", dir(posts_directory))
posts_paths <- here::here(posts_directory, dir(posts_directory), "index.qmd")

# Parse the YAML frontmatter of a post at `path` and return a data.frame.
# Attempts to parse only up to line `n` (default `n = 25` should be sufficient).
read_post_yaml <- function(path, n = 25) {
  lines <- readLines(path, n = n)
  yaml_breaks <- which(lines == "---")
  if (length(yaml_breaks) < 2) {
    return(out)
  }
  # TODO: Add the "categories" to filter on. They're a list column, so maybe
  # just grab up to the first three and make those 3 separate columns
  out <- data.frame(
    title = "",
    date = "",
    image = "",
    smallimage = "",
    description = "",
    summary = ""
  )
  yaml_lines <- lines[seq(yaml_breaks[[1]], yaml_breaks[[2]])]
  metadata <- yaml::read_yaml(text = paste(yaml_lines, collapse = "\n"))
  metadata_required_fields <- intersect(names(out), names(metadata))
  
  out[metadata_required_fields] <- metadata[metadata_required_fields]
  out["path"] <- path
  out
}

# Pass the metadata onto OJS
posts_metadata <- do.call(rbind, lapply(posts_paths, read_post_yaml))
posts_metadata$relative_folder_path <- posts_folders_relative_paths
ojs_define(posts_metadata)
```


```{ojs}
//| echo: false
//| output: false

// TODO:
// - hover effects for the points
// - tool-tips for the points (easier)
// - expanding points instead of tool-tip (harder)
// - custom filters for points

d3 = require("d3");

// TODO: You'll want to set up a custom class for these SVGs (and include the
// class as an attribute), so you can set the light/darkmode color using your
// .scss scripts

// Constants
lightblue = "#96BFE3";
offblack = "#1E1E1E";
offwhite = "#FFFBFC";
stroke_width = 0.25; // This is relative to the `viewBox` scale of the `svg`
n_cols = 12;
n_rows = 14;
width = n_cols * 10;
height = n_rows * 10;

// These describe the characteristics of the grid points and need to be tuned
// relative to one another such that the SVG text fits within an expanded grid
// point on mouse hover.
point_title_size = 3;
point_text_size = 2;
maximum_chars_per_line = 60;
point_width = 2;
point_height = 2;

// Prevents the right and bottom grid lines from being clipped
margin_bottom = stroke_width * 2;
margin_right = stroke_width * 2;
margin_top = 0;
margin_left = 0;

// Following this example: https://observablehq.com/@d3/scatterplot/2
svg = d3.select("#projects-grid")
  .append("svg")
  // Force the plot to a 2:3 aspect ratio, that fills the parent div width 100%
  .attr("viewBox", [0, 0, width, height])
  .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");

// Translates the full width into `n_cols` grid lengths
x = d3.scaleLinear()
  .domain([0, n_cols])
  .range([margin_left, width - margin_right]);

// Translates the full height into `n_rows` grid lengths
y = d3.scaleLinear()
  .domain([0, n_rows])
  .range([height - margin_bottom, margin_top]);

// TODO: Later we'll want to apply some filters to the data instead of
// randomly sampling

// Sample `n_posts` from the available posts
n_posts = 6;

// Decreasing the range to prevent points on the border of the grid
// TODO: We'll eventually want to prevent collisions, maybe by sampling
// within a disjoint grid for each point
random_x = d3.shuffle(d3.range(1 + 1, n_cols - 1)).slice(0, n_posts)
random_y = d3.shuffle(d3.range(1 + 1, n_rows - 1)).slice(0, n_posts)

// NOTE:
// - transpose() converts from an Object of Arrays to an Array of Objects
// - d3.shuffle() re-arranges the rows
// - .slice(0, n_posts) will sample `n_posts` of the shuffled rows
// - .map() is adding an x and y column using the randomly generated coordinates
sample_posts = d3.shuffle(transpose(posts_metadata))
  .slice(0, n_posts)
  .map((d, i) => ({
    x: random_x[i],
    y: random_y[i],
    ...d
  }));

popup = d3.select("#projects-grid")
  .append("div")
  .attr("class", "tooltip")
  .style("opacity", 0)
  .style("background-color", offwhite) // TODO: For testing
  .style("border", "solid")
  .style("border-width", "2px")
  .style("border-color", offblack)

mouseover = function(d) {
  
  // TODO: This is kind of gross, maybe wrap in helper functions. I'm wrapping
  // this in a function so I can call it after expanding the pop-up
  const append_text = function() {
    // TODO: YES! This appends a SVG <text> element to the parent node
    // On moveover we just need to use the provided data to add child
    // text elements to this group (we can even do links) and ensure that
    // they are styled correctly. We'll have the advantage of knowing
    // about the data and the position of this element!
    //
    // We can even use the x, y coordinates to determine whether we should
    // pop up/down and left/right so we don't clip out of the grid!
    const parent = d3.select(this.parentNode)
  
    // TODO: We may even want to just create this text at the beginning, within
    // the <g> group. Then, here we just make it opaque (from transparent) after
    // a delay of transition().delay("100") so it appears after the expansion.
    //
    // On second thought, since we're dynamically determining the direction of
    // the expansion (to avoid hitting a wall), why don't we just append the
    // required text here.
    const point_x = Number(d3.select(this).attr("x"))
    const point_y = Number(d3.select(this).attr("y"))
    
    // Adjust the corners of the SVG textbox
    const textbox_x = point_x + point_width;
    const textbox_y = point_y + point_height + point_title_size;
  
    parent
      .append("text")
      .classed("point-title", true)
      .text(d => d.title)
      .attr("x", textbox_x)
      .attr("y", textbox_y)
      .attr("font-size", point_title_size)
    
    // TODO: Move this to a function, maybe, and we'll also need to implement it
    // for the title text! Maybe we'll change the title font-size if the title is
    // super long as well.
    //
    // SVG <text> doesn't have line wrapping (as far as I know), so we'll
    // implement it manually. For each summary paragraph associated with a grid
    // point, wrap the summary text at `maximum_chars_per_line`.
    const line_height = point_text_size * 1.25;
    const summaries = parent.data().map(function(d) { return d.summary; })
    var line_y = textbox_y + point_title_size;
    
    for (var i = 0; i < summaries.length; i++) {
      const summary = summaries[i]
      const current_group = d3.select(parent.nodes()[i]) // <g> element we're appending to
      var words = summary.split(" ")
      var line = ""
      
      for (var j = 0; j < words.length; j++) {
        var test_line = line + " " + words[j]
        
        // TODO: This breaks with words > 20 characters long. Implement hyphenation
        // of those words.
        
        // If the test line is too long, append the current line as a child of
        // the current_group <g>
        if (test_line.length > maximum_chars_per_line) {
          current_group
            .append("text")
            .classed("point-text", true)
            .text(line)
            .attr("x", textbox_x)
            .attr("y", line_y)
            .attr("font-size", point_text_size)
          
          // Increment the line counter so we offset the y of the next line
          line_y += line_height;
          line = words[j];
          // TODO: I think ^ this point where the line is just one word long is
          // where we'll want to check for 20+ character words. Although, we could
          // do a super long word check at any-time and then break it up.
        }
        else {
          line = test_line
        }
      }
      // We'll have one final line to append at the end of the process
      if (line != "") {
        current_group
          .append("text")
          .classed("point-text", true)
          .text(line)
          .attr("x", textbox_x)
          .attr("y", line_y)
          .attr("font-size", point_text_size)
      }
    }
  }

  // Expand the grid point and then insert the summary text within it.
  // TODO: Re-work this system a little bit so we can handle custom heights
  d3.select(this)
    .transition()
    .duration("300")
    .attr("width", point_width * 30)
    .attr("height", point_height * 20)
    .attr("fill-opacity", 1)
    .on("end", append_text)
}

mouseleave = function(d) {
  // Clean up any text generated during mouse over
  d3.selectAll(".point-title").remove()
  d3.selectAll(".point-text").remove()
  
  // De-expand the grid-point to it's original width
  d3.select(this)
    .transition()
    .duration("100")
    .attr("width", point_width)
    .attr("height", point_height)
    .attr("fill-opacity", 0)
}

click = function(event, d) {
  if (this.classList.contains("open")) {
    d3.select(this).classed("open", false);
  }
  else {
    // Close any currently open points and open this point
    d3.selectAll(".grid-point").classed("open", false)
    d3.select(this).classed("open", true)
    
    d3.select(this)
      .transition()
      .duration("100")
      .attr("width", point_width * 1.5 * 10)
      .attr("height", point_height * 1.5 * 10)
      .attr("fill-opacity", 1)
    
    d3.select(this.parentNode)
      .append("text")
      .text(d => d.title)
    /*
    
    // Get the exact position of the SVG rectangle
    const box = this.getBoundingClientRect();
    const x = box.left + window.scrollX - 1;
    const y = box.top + window.scrollY - 1; 
    
    popup
      .style("width", box.width - 3 + "px")
      .style("height", box.height - 3 + "px")
      .style("opacity", 1)
      .style("left", x + "px")
      .style("top", y + "px")
      // .transition()
      // .duration("400")
      // .style("width", "200px")
      // .style("height", "200px")
    
    */
  }
}

// TODO: Here's the weird new strategy
// We're going to insert or remove sibling elements on the fly on mouse over:
//
// Sibling Insert:
// https://stackoverflow.com/questions/28249941/how-to-insert-after-a-sibling-element-in-d3-js
//
// When the rect is moused over, we'll insert sibling text elements using the
// data and then remove them once it's closed.
//
// Remove (we will just remove every SVG text element)
// https://stackoverflow.com/questions/44079951/remove-element-in-d3-js
//
// Add the grid points
svg.append("g")
  .selectAll("g")
  .data(sample_posts)
  .enter()
  .append("g")
  .append("rect")
    .attr("x", d => x(d.x) - (3 * stroke_width))
    .attr("y", d => y(d.y) - (3 * stroke_width))
    .attr("width", 2)
    .attr("height", 2)
    .attr("stroke", offblack)
    .attr("stroke-width", stroke_width)
    .attr("fill", offwhite)
    .attr("fill-opacity", 0)
    .classed("grid-point", true)
    .on("mouseover", mouseover)
    .on("mouseleave", mouseleave)

// Add the grid lines
svg.append("g")
  .attr("stroke", lightblue)
  .attr("stroke-width", stroke_width)
  .call(g => g.append("g")
    .selectAll("line")
    .data(x.ticks())
    .join("line")
      // `(stroke_width / 2)` centers the line to adjust for the stroke width on
      // the left and right sides of the line
      .attr("x1", d => (stroke_width / 2) + x(d))
      .attr("x2", d => (stroke_width / 2) + x(d))
      .attr("y1", margin_top)
      .attr("y2", height - margin_bottom))
  .call(g => g.append("g")
    .selectAll("line")
    .data(y.ticks())
    .join("line")
      .attr("y1", d => (stroke_width / 2) + y(d))
      .attr("y2", d => (stroke_width / 2) + y(d))
      .attr("x1", margin_left)
      .attr("x2", width - margin_right))
  // HACK: Without this there's a tiny gap in the bottom left corner. The
  // example has this issue as well, not sure of a better fix yet.
  .call(g => g.append("g")
    .selectAll("line")
    .data(y.ticks().slice(0, 1))
    .join("line")
      .attr("y1", d => (stroke_width / 2) + y(d))
      .attr("y2", d => (stroke_width / 2) + y(d))
      .attr("x1", margin_left)
      // Extending one stroke width past the margin to fill in the gap
      .attr("x2", width - margin_right + stroke_width));
```


<!--This is the container for the D3 above--->
<div id="projects-grid"></div>

::: {.grid}

::: {.g-col-6}
<h3>About this Website</h3>
This website is hosted on Netlify, programmed in R, using Quarto.
See this <a href="https://github.com/EthanSansom/ethansansom.com" class="black-link">github repository</a> for the source code. The dynamic elements 
on this page are programmed using the D3 Javascript library.
:::

::: {.g-col-6}
<h3>Contact</h3>
I haven't set up a way for you to contact me yet.
:::

:::

<br>
<br>
<br>
