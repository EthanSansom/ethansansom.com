---
page-layout: custom
---

```{r notes}
#| echo = FALSE

# TODO:
# IMPORTANT:
# See here: https://stackoverflow.com/questions/15649244/responsive-font-size-in-css
# For a responsive font-size suggestion from ashuvssut (not at the top).
#
# // Clamp font size
# h1{
#  font-size : clamp(2rem, 10vw, 5rem);
# }
#
# // Clamp font awesome icon size (we should use these)
# .fa-random-icon {
#   font-size: clamp( 15rem, 80vw, 80vh)   
# }
#
# TODO: Make a clearer system for the sizing (and relative sizing)
# of all the fonts in the ecosystem:
# - body
# - page title
# - navbar title + navbar logo text
# - headers
```

Hi. I’m Ethan, a Masters of Statistics student at the University of Toronto. I also work as a freelance data-analyst for the <a href="https://www.openresearchlab.org/about" class="black-link">Open Research Lab</a>, a San Fransisco based research group, and for Toronto’s own <a href="https://www.cleanairpartnership.org/about/" class="black-link">Clean Air Partnership</a>, a charitable environmental organization.

My research interests include reproducibility in social science research, causal inference, and statistical software design. Click the black boxes ↓ to preview some of my personal projects.

```{r load-posts}
#| include = FALSE

library(yaml)
library(here)

posts_directory <- here::here("posts")
posts_folders_relative_paths <- file.path("posts", dir(posts_directory))
posts_paths <- here::here(posts_directory, dir(posts_directory), "index.qmd")

# Parse the YAML frontmatter of a post at `path` and return a data.frame.
# Attempts to parse only up to line `n` (default `n = 25` should be sufficient).
read_post_yaml <- function(path, n = 25) {
  lines <- readLines(path, n = n)
  yaml_breaks <- which(lines == "---")
  if (length(yaml_breaks) < 2) {
    return(out)
  }
  # TODO: Add the "categories" to filter on. They're a list column, so maybe
  # just grab up to the first three and make those 3 separate columns
  out <- data.frame(
    title = "",
    date = "",
    image = "",
    smallimage = "",
    description = "",
    summary = ""
  )
  yaml_lines <- lines[seq(yaml_breaks[[1]], yaml_breaks[[2]])]
  metadata <- yaml::read_yaml(text = paste(yaml_lines, collapse = "\n"))
  metadata_required_fields <- intersect(names(out), names(metadata))
  
  out[metadata_required_fields] <- metadata[metadata_required_fields]
  out["path"] <- path
  out
}

# Pass the metadata onto OJS
posts_metadata <- do.call(rbind, lapply(posts_paths, read_post_yaml))
posts_metadata$relative_folder_path <- posts_folders_relative_paths
ojs_define(posts_metadata)
```


```{ojs}
//| echo: false
//| output: false
d3 = require("d3");

// TODO:
// - custom filters for points

// TODO: You'll want to set up a custom class for these SVGs (and include the
// class as an attribute), so you can set the light/darkmode color using your
// .scss scripts

// Constants
lightblue = "#96BFE3";
offblack = "#1E1E1E";
offwhite = "#FFFBFC";
stroke_width = 0.25; // This is relative to the `viewBox` scale of the `svg`
n_cols = 12;
n_rows = 14;
middle_col = Math.floor(n_cols / 2);
middle_row = Math.floor(n_rows / 2);
width = n_cols * 10;
height = n_rows * 10;

// These describe the characteristics of the grid points and need to be tuned
// relative to one another such that the SVG text fits within an expanded grid
// point on mouse hover.
point_title_size = 3;
point_text_size = 2;
maximum_chars_per_line = 60;
point_width = 2;
point_height = 2;

// Prevents the right and bottom grid lines from being clipped
margin_bottom = stroke_width * 2;
margin_right = stroke_width * 2;
margin_top = 0;
margin_left = 0;

// Following this example: https://observablehq.com/@d3/scatterplot/2
svg = d3.select("#projects-grid")
  .append("svg")
  // Force the plot to width/height aspect ratio which fills the parent width
  .attr("viewBox", [0, 0, width, height])
  .attr("style", "max-width: 100%; height: auto;");

// Use the SVG <use> feature to control which grid point is rendered on top
use = svg
  .append("use")
  .attr("xlink:href", "")

// Translates the full width into `n_cols` grid lengths
x = d3.scaleLinear()
  .domain([0, n_cols])
  .range([margin_left, width - margin_right]);

// Translates the full height into `n_rows` grid lengths
y = d3.scaleLinear()
  .domain([0, n_rows])
  .range([height - margin_bottom, margin_top]);

// TODO: Later we'll want to apply some filters to the data instead of
// randomly sampling

// Generate random `(x, y)` coordinates for each post.
// - Shuffling creates distinct `(x, y)` coordinates, i.e. no overlapping posts
// - Restricting the range to avoid coordinates on the edge of the grid
n_posts = 6;
random_x = d3.shuffle(d3.range(1 + 1, n_cols - 1)).slice(0, n_posts)
random_y = d3.shuffle(d3.range(1 + 1, n_rows - 1)).slice(0, n_posts)

// Sample `n_posts` and assign random `(x, y)` coordinates
sample_posts = d3.shuffle(transpose(posts_metadata))
  .slice(0, n_posts)
  .map((d, i) => ({
    x: random_x[i],
    y: random_y[i],
    ...d
  }));

// For each grid-point we need to dynamically create it's size (when expanded)
// to allocate enough vertical space to fit every line of text in the grid-point
// description. We call this on every grid-point container (after they are
// created below) to create the grid-points associated text elements as sibling
// nodes and inform the grid-point (via data attributes) of the size it should
// expand to in order to fit all of it's description text.
add_grid_point_text = function(d) {
  // We're acting on the parent <g> container, which is `this` but we really 
  // care about editing the grid-point and it's siblings (text elements).
  const parent = d3.select(this)
  const grid_point = parent.select("rect")
  
  // Determine in which direction the point should expand
  const expand_dir_x = grid_point.attr("data-expand-dir-x");
  const expand_dir_y = grid_point.attr("data-expand-dir-y");
  
  // Determine where the current point and text-box live
  const point_x = Number(grid_point.attr("x"))
  const point_y = Number(grid_point.attr("y"))
  const textbox_x = point_x + point_width;
  const textbox_y = point_y + point_height + point_title_size;
  
  // Append the title text
  parent
    .append("text")
    .classed("point-title", true)
    .text(d => d.title)
    .attr("x", textbox_x)
    .attr("y", textbox_y)
    .attr("font-size", point_title_size)
  
  // SVG <text> doesn't have line wrapping (as far as I know), so we'll
  // implement it manually. For each summary paragraph associated with a grid
  // point, wrap the summary text at `maximum_chars_per_line`.
  const line_height = point_text_size * 1.25;
  const summary = d.summary
  
  var n_lines = 0;
  var line_y = textbox_y + point_title_size + point_text_size;
  var words = summary.split(" ")
  var line = ""
    
  for (var j = 0; j < words.length; j++) {
    // If the test line is too long, append the current line as a child of
    // parent <g> container.
    var test_line = line + " " + words[j]
    if (test_line.length > maximum_chars_per_line) {
      parent
        .append("text")
        .classed("point-text", true)
        .text(line)
        .attr("x", textbox_x)
        .attr("y", line_y)
        .attr("font-size", point_text_size)
      
      // Increment the line counter so we offset the y of the next line
      line_y += line_height;
      n_lines += 1;
      line = words[j];
    }
    else {
      line = test_line
    }
  }
  // We'll have one final line to append at the end of the process
  if (line != "") {
    parent
      .append("text")
      .classed("point-text", true)
      .text(line)
      .attr("x", textbox_x)
      .attr("y", line_y)
      .attr("font-size", point_text_size)
  }
  
  // Calculate the total width and height required for the expanded grid-point.
  // By default, the grid-point will expand towards the bottom-left of the page.
  // To expand in another direction (e.g. up-right), we offset the x, y position
  // of the point as we expand.
  const expanded_width = maximum_chars_per_line + point_width;
  const expanded_height = (n_lines * line_height) + (point_title_size * 4) + point_text_size;
  const x_offset = (expand_dir_x === "right") ? 0 : expanded_width - point_width;
  const y_offset = (expand_dir_y === "down") ? 0 : expanded_height - point_height;

  // Record the x, y, width, and height that the grid-point needs to expand to
  grid_point
    .attr("data-expanded-x", function() { 
      return d3.select(this).attr("data-original-x") - x_offset;
    })
    .attr("data-expanded-y", function() { 
      return d3.select(this).attr("data-original-y") - y_offset;
    })
    .attr("data-expanded-width", expanded_width)
    .attr("data-expanded-height", expanded_height)
    .attr("fill-opacity", 1)
  
  // Offset the text elements if required
  if (x_offset != 0 | y_offset != 0) {
     parent
      .selectAll(".point-title")
      .attr("x", function() { 
        return d3.select(this).attr("x") - x_offset;
      })
      .attr("y", function() { 
        return d3.select(this).attr("y") - y_offset;
      })
    parent
      .selectAll(".point-text")
      .attr("x", function() { 
        return d3.select(this).attr("x") - x_offset;
      })
      .attr("y", function() { 
        return d3.select(this).attr("y") - y_offset;
      })
  }
}
  
mouseenter = function(d) {
  // We're acting on the parent <g> container, which is `this` but we really 
  // care about editing the grid-point and it's siblings (text elements).
  const parent = d3.select(this)
  const grid_point = parent.select("rect")
  
  // Raise this <g> container to the top so it's contents appear above other
  // grid points.
  parent
    .raise()
    
  // Expand the grid point, offsetting the (x, y) position as needed
  grid_point
    .transition()
    .duration("300")
    .attr("x", function() { return d3.select(this).attr("data-expanded-x"); })
    .attr("y", function() { return d3.select(this).attr("data-expanded-y"); })
    .attr("width", function() { return d3.select(this).attr("data-expanded-width"); })
    .attr("height", function() { return d3.select(this).attr("data-expanded-height"); })
    .attr("fill-opacity", 1)
    // Not including a transition (e.g. fade) for the text because it's too easy
    // (if you wiggle the mouse a lot) to un-align the grid-point and grid-text
    // transitions.
    .on("end", () => {
      // Show the text
      parent.selectAll(".point-title")
        .style("opacity", 1)
      parent.selectAll(".point-text")
        .style("opacity", 1)
    });
}

mouseleave = function(d) {
  // Hide any point text or titles from the grid
  svg
    .selectAll(".point-title")
    .style("opacity", 0)
  svg
    .selectAll(".point-text")
    .style("opacity", 0)
  
  // De-expand the grid-point to it's original width
  d3.select(this)
    .select(".grid-point")
    .transition()
    .duration("300")
    // If the point expands anywhere except towards the bottom-left, then the
    // x, y coordinates were adjusted during the expansion and need to be reset
    .attr("x", function() { return d3.select(this).attr("data-original-x"); })
    .attr("y", function() { return d3.select(this).attr("data-original-y"); })
    .attr("width", point_width)
    .attr("height", point_height)
    .attr("fill-opacity", 0)
}

// Add the grid points
svg.append("g")
  .selectAll("g")
  .data(sample_posts)
  .enter()
  .append("g")
  .classed("grid-point-container", true)
  .on("mouseenter", mouseenter)
  .on("mouseleave", mouseleave)
  .call(g => g.append("rect")
    .classed("grid-point", true)
    .attr("id", (d, i) => "point" + i)
    .attr("x", d => x(d.x) - (3 * stroke_width))
    .attr("y", d => y(d.y) - (3 * stroke_width))
    .attr("data-original-x", d => x(d.x) - (3 * stroke_width))
    .attr("data-original-y", d => y(d.y) - (3 * stroke_width))
    .attr("data-expand-dir-x", d => (d.x > middle_col) ? "left" : "right")
    .attr("data-expand-dir-y", d => (d.y > middle_row) ?  "down" : "up")
    .attr("width", point_width)
    .attr("height", point_height)
    // TODO: Move these into the `light/dark.scss` as classes
    .attr("stroke", offblack)
    .attr("stroke-width", stroke_width)
    .attr("fill", offwhite)
    .attr("fill-opacity", 0)
  )
  // Add the grid-point text elements to each grid-point-container
  .each(add_grid_point_text)

// Add the grid lines
svg.append("g")
  .attr("stroke", lightblue)
  .attr("stroke-width", stroke_width)
  .call(g => g.append("g")
    .selectAll("line")
    .data(x.ticks())
    .join("line")
      // `(stroke_width / 2)` centers the line to adjust for the stroke width on
      // the left and right sides of the line
      .attr("x1", d => (stroke_width / 2) + x(d))
      .attr("x2", d => (stroke_width / 2) + x(d))
      .attr("y1", margin_top)
      .attr("y2", height - margin_bottom))
  .call(g => g.append("g")
    .selectAll("line")
    .data(y.ticks())
    .join("line")
      .attr("y1", d => (stroke_width / 2) + y(d))
      .attr("y2", d => (stroke_width / 2) + y(d))
      .attr("x1", margin_left)
      .attr("x2", width - margin_right))
  // HACK: Without this there's a tiny gap in the bottom left corner. The
  // example has this issue as well, not sure of a better fix yet.
  .call(g => g.append("g")
    .selectAll("line")
    .data(y.ticks().slice(0, 1))
    .join("line")
      .attr("y1", d => (stroke_width / 2) + y(d))
      .attr("y2", d => (stroke_width / 2) + y(d))
      .attr("x1", margin_left)
      // Extending one stroke width past the margin to fill in the gap
      .attr("x2", width - margin_right + stroke_width));
```


<!--This is the container for the D3 above--->
<div id="projects-grid"></div>

::: {.grid}

::: {.g-col-6}
<h3>About this Website</h3>
This website is hosted on Netlify, programmed in R, using Quarto.
See this <a href="https://github.com/EthanSansom/ethansansom.com" class="black-link">github repository</a> for the source code. The dynamic elements 
on this page are programmed using the D3 Javascript library.
:::

::: {.g-col-6}
<h3>Contact</h3>
I haven't set up a way for you to contact me yet.
:::

:::

<!--TODO: Add a footer!--->
<br>
<br>
<br>
