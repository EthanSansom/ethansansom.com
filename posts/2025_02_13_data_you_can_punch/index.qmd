---
title: "Data You Can Punch"
date: "2025-02-12"
categories: ["D3", "Data Visualization"]
# image: "vlightr_hex.png"
# smallimage: '<img src="posts/2025_01_30_vlightr/vlightr_small.png">'
summary: |
  Data you can punch.
editor: 
  markdown: 
    wrap: 72
---

<br>

Have you ever opened a dataset to find out that every second value was missing?
Were you forced to manually geo-code the last 2,000 addresses when you ran out
of Google Maps API requests? Was your original thesis scrapped because every
result turned out insignificant?

This is a plot for anyone who's ever been hurt by bad data. Grab the "fist"
below and vent your frustration.

:::: {#plot-title}
::::

:::: {#matter-container}
::::

```{ojs}
//| echo: false
//| output: false

// TODO: 
// - Read all of: https://blog.djnavarro.net/posts/2024-01-09_observable-js-art/
// - Look at the Matter.js documentation page (and examples at the bottom) for
//   style inspiration!
//    - Implement some kind of fun physics simulation for your about page

// TODO: Think about the margins. Make some functions which take SVG co-ordiantes
// that D3 expects and the margins and convert them to Matter coordinates so I
// don't need to think about it!

// TODO: Clean up all of this code and make a `reset` button, so you don't
// need to refresh the page! Basically, just wrap all of this code in a function.
// Have D3 fade out any remaining objects and then fade them all back in afterwards.
// Have the fist drop from the sky on reset!
// Have the title of the plot increment!

// TODO: Manually set the z-index of text on this page to -1, since the effect
// is way more fun when the text goes behind the "fist".

// TODO: Don't colour things manually, make some classes in the custom light
// and custom dark CSS which we can use for data elements in the normal plots.
// Since I'll mostly just be done the blue + black + white thing.

// Imports ---------------------------------------------------------------------

d3 = require("d3");
Matter = require("matter-js");

Engine = Matter.Engine
Bodies = Matter.Bodies
Composite = Matter.Composite

// Constants -------------------------------------------------------------------

// Colors
offwhite = "#FFFBFC";

// Dimensions of the SVG viewbox, defines our world-space
width = 800;
height = 400;
stroke_width = 1;

margin_left = 10;
margin_right = 100; // Leave room for the "fist"
margin_top = 10;
margin_bottom = 10;

// Collision filters, note that these need to be powers of 2
collision_fist = 0x0001; 
collision_bar = 0x0002;
collision_mouse = 0x0004;

// TODO: Automate the simulation of this data, do it relative to the current
// year, then do the last 20 years or so
// Sample data
data = [
  { label: 1995, value: 10 },
  { label: 1996, value: 20 },
  { label: 1997, value: 10 },
  { label: 1998, value: 30 },
  { label: 1999, value: 45 },
  { label: 2000, value: 47 },
  { label: 2001, value: 56 },
  { label: 2002, value: 80 },
  { label: 2003, value: 95 },
  { label: 2004, value: 90 },
  { label: 2005, value: 47 },
  { label: 2006, value: 56 },
  { label: 2007, value: 80 },
  { label: 2008, value: 95 },
  { label: 2009, value: 90 },
];

plot_titles = [
  "Simulated Data",
  "P-value of 0.55 (never published)",
  "P-value of 0.00001",
  "Didn’t survive FDR",
  "Lasso selected none of my favourites",
  "Adding another hyper-prior didn’t help",
  "32 hour bootstrap"
];

mutable plot_title_index = 0;

// Helpers ---------------------------------------------------------------------

// Transform coordinate you'd provide to initialize a Matter.js rectangle
// to the points of an SVG <polygon>. Assumes that (x, y) is top left.
rectangle_points = function(x, y, width, height) {
  const top_left = `${x},${y}`;
  const bottom_left = `${x},${y + height}`;
  const top_right = `${x + width},${y}`;
  const bottom_right = `${x + width},${y + height}`;
  return top_left + " " + top_right + " " + bottom_right + " " + bottom_left;
}

// Transform Matter body vertices into SVG <polygon> points
vertices_to_points = function(vertices) {
  return vertices.map(vertex => `${vertex.x},${vertex.y}`).join(" ")
}

// Transform SVG <polygon> points into Matter body vertices
points_to_vertices = function(points) {
  return points.split(" ").map(point => point.split(",")).map(xy => ({ x: xy[[0]], y: xy[[1]] }))
}

// SVG -------------------------------------------------------------------------

// TODO: Add a toggle for the physics simulation! Turn on/off ("Make Punchable")
// https://gsap.com/community/forums/topic/37757-scrolltrigger-matterjs-animation/
// Also, see how to do scroll events!
//
// onToggle: (self) =>  {
// console.log("toggled, isActive:", self.isActive)
// engine.enabled = self.isActive
// },

// Move the z-index of all text backwards, because it looks cooler
d3.select("#title-block-header")
  .style("position", "relative")
  .style("z-index", -1);

// Set the plot title
plot_title = d3.select("#plot-title")
  .append("h3")
  .text(plot_titles[plot_title_index])
  .style("padding-bottom", "0.5em")
  // Position the title behind the SVG elements and don't let the cursor
  // highlight it (which happens a lot when dragging the "fist").
  .style("position", "relative")
  .style("z-index", -1)
  .style("user-select", "none");

// Set the SVG viewbox
svg = d3.select("#matter-container")
  // TODO: I've only gotten Matter.js to work with a fixed width/height 
  // container. Look into whether a reactive size is possible!
  // The mouse has an offset and scale, there's probably a way to allow
  // for resizing: https://brm.io/matter-js/docs/classes/Mouse.html
  //
  // Maybe helpful:
  // https://stackoverflow.com/questions/64302906/scaling-matter-js-canvas-breaks-mouse-drag
  // https://github.com/liabru/matter-js/issues/955
  // https://www.youtube.com/watch?v=kdSDTaYY700
  .style("width", width + "px")
  .style("height", height + "px")
  .append("svg")
  .attr("viewBox", [0, 0, width, height])
  .attr("style", "max-width: 100%; height: auto;")
  // This makes the physics so much more fun!
  .attr("overflow", "visible");

// TODO: Now what we want to do is this:
//
// 1. Take in input data as normal and initialize a set of SVGs using D3
// 2. For each SVG initialized by D3, initialize a corresponding physics object with Matter.js
// 3. Magic. Create the `update()` loop and on each update:
// - Update the physics objects with Matter.Engine.update()
// - Update the SVG positions to their new locations with D3

// Scales
x_axis = d3.scaleBand()
  .domain(data.map(d => d.label))
  .range([margin_left, width - margin_right])
  .padding(0.2);

y_axis = d3.scaleLinear()
  .domain([0, d3.max(data, d => d.value)])
  .range([height - margin_top, margin_bottom]);
  
// Add axes
x_axis_selection = svg.append("g")
  .classed("x-axis", true)
  // Account for the stroke width of both the bars and the axis itself
  .attr("transform", `translate(0,${height - margin_bottom + (stroke_width)})`)
  .call(d3.axisBottom(x_axis).tickSizeOuter(0))
  // Extend the right-side of the axis line to account for the right margin.
  // This gives a spot for the `fist` to land. We have to manually alter the `d`
  // attribute of the <path>.
  .call(g => {
    const old_path = g.select(".domain").attr("d");
    const new_path = old_path.replace(/H(\d+)/, (match, p1) => `H${+p1 + margin_right}`);
    g.select(".domain").attr("d", new_path);
  })
  .call(g => g.select(".domain").attr("stroke-width", stroke_width))
  .call(g => g.selectAll("line").attr("stroke-width", stroke_width))
  .call(g => g.append("text")
    .attr("x", width - margin_right)
    // Grab the y-position from the existing tick labels, so this is aligned
    .attr("y", g.select(".tick text").attr("y"))
    .attr("dy", g.select(".tick text").attr("dy"))
    .attr("fill", "currentColor")
    .attr("text-anchor", "start")
    .text("Year →")
  );

x_axis_selection
  .selectAll("line")
  .attr("stroke-width", stroke_width / 2);

y_axis_selection = svg.append("g")
  .classed("y-axis", true)
  // +1 to connect the axis tick at `0` with the x-axis line
  .attr("transform", `translate(${margin_left + 1}, ${stroke_width})`)
  .call(d3.axisLeft(y_axis))
  .call(g => g.select(".domain").remove())
  .call(g => g.selectAll("line").attr("stroke-width", stroke_width))
  .call(g => g.append("text")
    .attr("x", -margin_left)
    .attr("y", 10)
    .attr("fill", "currentColor")
    .attr("text-anchor", "middle")
    .text("↑ Value")
  );

// Set the axis font to the website-wide default and prevent user selection of text
x_axis_selection
  .selectAll("text")
  .style("font-family", "var(--bs-body-font-family)")
  .style("user-select", "none");

y_axis_selection
  .selectAll("text")
  .style("font-family", "var(--bs-body-font-family)")
  .style("user-select", "none");

// Physics ---------------------------------------------------------------------

// Create an engine
engine = Engine.create();

// Create bodies corresponding to each bar in bar chart
svg
  .selectAll(".bar")
  .data(data)
  // Initialize a <polygon> for each bar. We'll use the vertices
  // provided by Matter to draw these later.
  .join("polygon")
  .classed("plot-data-blue", true)
  .attr("stroke-width", stroke_width)
  .attr("data-label", d => d.label)
  // Initialize a Matter physics body for each bar. Note `this` means something
  // different if you using a `=>` function here - be aware!
  .each(function(d, i) {
    
    const x = x_axis(d.label); // Data `x` in terms of view-space
    const bar_width = x_axis.bandwidth(); // Keep bar width < 1
    const bar_height = height - margin_bottom - y_axis(d.value);
    
    // Matter expects centered x, y coordinates whereas SVG and D3 expects
    // coordinates relative to the top-left.
    const body = Bodies.rectangle(
      // Center relative to the full band-width, to put each bar in the middle
      x + (bar_width / 2),
      height - margin_bottom - (bar_height / 2),
      bar_width, 
      bar_height,
      {
        collisionFilter: {
          category: collision_bar,
          mask: collision_fist | collision_bar
        }
      }
    );
    Composite.add(engine.world, body);
    
    // Synchronize the D3 and Matter IDs and positions
    d3.select(this)
      .attr("id", `body-${body.id}`)
      .attr("points", vertices_to_points(body.vertices))
      .raise()
  });

// Create an invisible ground for the bars to sit on. The width shouldn't matter
// that much but I imagine thicker is a little better for collision detection.
ground_width = 50;
ground = Bodies.rectangle(
  width / 2, height - (margin_bottom / 2), width, margin_bottom,
  { 
    isStatic: true, 
    label: "ground"
  }
);
Composite.add(engine.world, ground);

/* Renders the ground
svg.append('polygon')
  .attr("id", `body-${ground.id}`)
  .attr("points", vertices_to_points(ground.vertices))
  .attr("fill", offblack)
*/

// Using a mask to ensure that the mouseContstraint can only interact with the
// fist:
// https://stackoverflow.com/questions/64772783/how-can-i-change-the-collisionfilter-of-an-object-so-it-can-no-longer-interact-w/73262781#73262781

// Add a circular body for the "fist"
fist_radius = (margin_right / 2) * 0.8; // Slightly smaller diameter than the space for it
fist = Bodies.polygon(
  width - (margin_right / 2), // Placed in the middle of the right margin
  height - (margin_bottom / 2) - (fist_radius / 2), // Initially sitting on the ground
  fist_radius,
  50, // 50 sided
  {
    collisionFilter: {
      category: collision_fist,
      mask: collision_fist | collision_bar | collision_mouse
    }
  }
);
Composite.add(engine.world, fist);

// Render the Fist
svg
  .append("g")
  .classed("fist-container", true)
  .call(g => g.append('polygon')
    .attr("id", `body-${fist.id}`)
    .attr("points", vertices_to_points(fist.vertices))
    .classed("plot-data-black", true)
    // .attr("fill", offwhite)
    // .attr("stroke", offblack)
    .attr("stroke-width", stroke_width)
    // Change the cursor icon while interacting with the fist to make it more
    // obvious that you can drag it.
    .style("cursor", "grab")
    .on("mousedown", function() {
      d3.select(this).style("cursor", "grabbing");
      // Remove the user-prompt to pick up the fist once they've grabbed it
      d3.select("#fist-prompt")
        .attr("pointer-events", "none")
        .transition()
        .duration(1000)
        .style("opacity", 0)
        .on("end", function() { d3.select(this).remove(); })
    })
    .on("mouseup", function() {
      d3.select(this).style("cursor", "grab");
    })
  )
  .call(g => g.append("text")
    .classed("plot-annotation", true)
    .attr("id", `body-text-${fist.id}`)
    .attr("x", fist.position.x)
    .attr("y", fist.position.y)
    .attr("text-anchor", "middle") // Centers text horizontally
    .attr("dominant-baseline", "middle") // Centers text vertically
    .attr("font-size", 16)
    .attr("font-weight", 400)
    .text("fist")
    // Prevents trying to copy/highlight the text, which happens a lot on drag
    .style("user-select", "none")
    .style("pointer-events", "none")
  )
  .raise();

// Add a label above the fist
svg.append("g")
  .attr("id", "fist-prompt")
  .call(g => g.append("text")
    .classed("plot-annotation", true)
    .attr("x", fist.position.x)
    .attr("y", fist.position.y - fist_radius - 80)
    .attr("text-anchor", "middle")
    .attr("font-size", 16)
    .attr("font-weight", 400)
    .text("Pick Up")
  )
  .call(g => g.append("text")
    .classed("plot-annotation", true)
    .attr("x", fist.position.x)
    .attr("y", fist.position.y - fist_radius - 80 + 18)
    .attr("text-anchor", "middle")
    .attr("font-size", 16)
    .attr("font-weight", 400)
    .text("↓")
  )

// Add a mouse constraint
mouse = Matter.Mouse.create(document.querySelector("#matter-container"));
// mouse.pixelRatio = window.devicePixelRatio; // TODO: Figure this out
mouse_constraint = Matter.MouseConstraint.create(engine, {
  mouse: mouse,
  collisionFilter: {
    category: collision_mouse,
    mask: collision_fist
  },
  constraint: { stiffness: 0.5 }
})
Composite.add(engine.world, mouse_constraint);

// This is a global variable which records all physic objects in the scene
bodies = engine.world.bodies;

// Make sure the axes appear behind other objects
x_axis_selection.lower();
y_axis_selection.lower();
```

```{ojs}
//| echo: false
//| output: false

// TODO: I bet we could expose `bodies` to D3 as a dataset, and make updating
// more slick. Although, as it is it's very short.

// Implement the engine/render update loop. We're using D3 to update the
// positions and Matter.js to update the physics engine.
function* update() {
  
  while (true) {
    // Update the engine
    Engine.update(engine, 5)
    
    // TODO: We could remove bodies (via Matter) and polygons (via D3) once
    // they've left the screen to get some more performance. Doesn't really
    // matter for this demo.
    
    // TODO: Add a gravity slider!
    
    // Move the vertices of every body to their new positions. This is the SVG
    // equivalent of Matter's example <canvas> render loop: 
    // https://github.com/liabru/matter-js/wiki/Rendering
    bodies.filter(body => body.label != "ground").forEach(body => {
      svg.select(`#body-${body.id}`)
        .attr('points', vertices_to_points(body.vertices));
      
      // Matter.js angle is in radians, convert to degress
      const body_angle = body.angle * (180 / Math.PI);
      const body_x = body.position.x;
      const body_y = body.position.y;
      svg.select(`#body-text-${body.id}`)
        .attr("x", body_x)
        .attr("y", body_y)
        .attr("transform", `rotate(${body_angle}, ${body_x}, ${body_y})`);
    })
    
    // Finish
    yield
  }
}
```


```{ojs}
//| echo: false
//| output: false
update();
```

