---
title: "Data You Can Punch"
date: "2025-02-12"
categories: ["D3", "Data Visualization"]
# image: "vlightr_hex.png"
# smallimage: '<img src="posts/2025_01_30_vlightr/vlightr_small.png">'
description: |
  Data you can punch.
summary: |
  Data you can punch.
editor: 
  markdown: 
    wrap: 72
---

<br>

This is a test of punch-able data

:::: {#matter-container}
::::

```{ojs}
//| echo: false
//| output: false

// TODO: 
// - Read all of: https://blog.djnavarro.net/posts/2024-01-09_observable-js-art/
// - Look at the Matter.js documentation page (and examples at the bottom) for
//   style inspiration!
//    - Implement some kind of fun physics simulation for your about page

// Imports ---------------------------------------------------------------------

d3 = require("d3");
Matter = require("matter-js");

Engine = Matter.Engine
Bodies = Matter.Bodies
Composite = Matter.Composite

// Constants -------------------------------------------------------------------

// Colors
offblack = "#1E1E1E";
offwhite = "#FFFBFC";
lightblue = "#96BFE3";

// Dimensions of the SVG viewbox, defines our world-space
width = 600;
height = 400;
stroke_width = 2;

margin_left = 10;
margin_right = 10;
margin_top = 10;
margin_bottom = 10;

// Sample data
data = [
  { label: "A", value: 10 },
  { label: "B", value: 25 },
  { label: "C", value: 15 },
  { label: "D", value: 30 },
  { label: "E", value: 20 }
];

// Helpers ---------------------------------------------------------------------

// Transform coordinate you'd provide to initialize a Matter.js rectangle
// to the points of an SVG <polygon>. Assumes that (x, y) is top left.
rectangle_points = function(x, y, width, height) {
  const top_left = `${x},${y}`;
  const bottom_left = `${x},${y + height}`;
  const top_right = `${x + width},${y}`;
  const bottom_right = `${x + width},${y + height}`;
  return top_left + " " + top_right + " " + bottom_right + " " + bottom_left;
}

// Transform Matter body vertices into SVG <polygon> points
vertices_to_points = function(vertices) {
  return vertices.map(vertex => `${vertex.x},${vertex.y}`).join(" ")
}

// Transform SVG <polygon> points into Matter body vertices
points_to_vertices = function(points) {
  return points.split(" ").map(point => point.split(",")).map(xy => ({ x: xy[[0]], y: xy[[1]] }))
}

// SVG -------------------------------------------------------------------------

svg = d3.select("#matter-container")
  .append("svg")
  .attr("viewBox", [0, 0, width, height])
  .attr("style", "max-width: 100%; height: auto;");

// TODO: Now what we want to do is this:
//
// 1. Take in input data as normal and initialize a set of SVGs using D3
// 2. For each SVG initialized by D3, initialize a corresponding physics object with Matter.js
// 3. Magic. Create the `update()` loop and on each update:
// - Update the physics objects with Matter.Engine.update()
// - Update the SVG positions to their new locations with D3

// Scales
x_axis = d3.scaleBand()
  .domain(data.map(d => d.label))
  .range([margin_left, width - margin_right]);

y_axis = d3.scaleLinear()
  .domain([0, d3.max(data, d => d.value)])
  .nice()
  .range([height - margin_bottom, margin_top]);

svg
  .selectAll(".bar")
  .data(data)
  .join("polygon")
  .attr('id', (d, i) => `box-${i}`)
  .attr('points', d =>
    rectangle_points(
      x_axis(d.label), // `x` scaled to view-space
      y_axis(d.value), // `y` scaled to view-space
      x_axis.bandwidth() * 0.75, // Width, don't make the bars full-width
      height - margin_bottom - y_axis(d.value) // Height
    )
  )
  .attr("fill", offwhite)
  .attr("stroke", lightblue)
  .attr("stroke-width", stroke_width)

// Physics ---------------------------------------------------------------------

// TODO: Transfer the bar data 

// Create an engine
engine = Engine.create();

// Create bodies corresponding to each rectangle in the scene
svg
  .each((d, i) => {
    // Repeating what I did to make the SVG, maybe more elegant to create the
    // bodies first and then just extract their coordinate for the SVG
    const x = x_axis(d.label);
    const y = y_axis(d.value);
    const width = x_axis.bandwidth() * 0.75;
    const height = height - margin_bottom - y_axis(d.value);
    
    // Matter expects centered x, y coordiantes
    body = Bodies.rectangle(x - (width / 2), y - (height / 2), width, height);
    Composite.add(engine.world, [body]);

  })
  .data(data)
  .join("polygon")
  .attr('id', (d, i) => `box-${i}`)
  .attr('points', d =>
    rectangle_points(
      x_axis(d.label), // `x` scaled to view-space
      y_axis(d.value), // `y` scaled to view-space
      x_axis.bandwidth() * 0.75, // Width, don't make the bars full-width
      height - margin_bottom - y_axis(d.value) // Height
    )
  )
  .attr("fill", offwhite)
  .attr("stroke", lightblue)
  .attr("stroke-width", stroke_width)

// Create two boxes and a ground
/*
boxA = Bodies.rectangle(300, 40, 80, 80);
boxB = Bodies.rectangle(350, 200, 80, 80);
ground = Bodies.rectangle(
  300, 350, 550, 50, 
  { 
    isStatic: true, 
    label: "ground",
    chamfer: { radius: 10 }
  }
);
*/

// Add all of the bodies to the world
Composite.add(engine.world, [boxA, boxB, ground]);

// This will record all physic objects in the scene
// bodies = Composite.allBodies(engine.world);
bodies = engine.world.bodies;

// Rendering -------------------------------------------------------------------

// Add each physics object as an SVG
bodies.forEach(body => {
  svg.append('polygon')
    .attr('id', `box-${body.id}`)
    .attr('points', vertices_to_points(body.vertices))
    .attr('fill', offwhite)
    .attr('stroke', lightblue)
    // Stroke width will cause physics objects to overlap slightly but it is
    // really annoying to correct - <svg> does not have a nice inner stroke API
    .attr('stroke-width', stroke_width)
})

```

```{ojs}
//| echo: false
//| output: false

/*

// TODO: I bet we could expose `bodies` to D3 as a dataset, and make updating
// more slick. Although, as it is it's very short.

// Implement the engine/render update loop. We're using D3 to update the
// positions and Matter.js to update the physics engine.
function* update() {
  
  while (true) {
    // Update the engine
    Engine.update(engine, 5)
    
    // Move the vertices of every body to their new positions. This is the SVG
    // equivalent of Matter's example <canvas> render loop: 
    // https://github.com/liabru/matter-js/wiki/Rendering
    bodies.forEach(body => {
      svg.select(`#box-${body.id}`)
        .attr('points', vertices_to_points(body.vertices))
    })
    
    // Finish
    yield
  }
}

*/
1 + 1
```


```{ojs}
//| echo: false
//| output: false

// update();
1 + 1
```

